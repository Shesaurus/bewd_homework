# HOW blocks differ from methods
# method that capitalizes a word
def capitalize(string) 
  puts "#{string[0].upcase}#{string[1..-1]}"
end

capitalize("ryan") # prints "Ryan"
capitalize("jane") # prints "Jane"

# block that capitalizes each string in the array
["ryan", "jane"].each {|string| puts "#{string[0].upcase}#{string[1..-1]}"} # prints "Ryan", then "Jane"
=>
Ryan
Jane
Ryan
Jane
["ryan", "jane"]

# The block, {|i| puts i}, is passed the current
# array item each time it is evaluated. This block
# prints the item. 
[1, 2, 3, 4, 5].each { |i| puts i }

# This block prints the number 5 for each item.
# (It chooses to ignore the passed item, which is allowed.)
[1, 2, 3, 4, 5].each { |i| puts i * 5 }

=>5, 10, 15, 20, 25



<code>my_vitamins = ['b-12', 'c', 'riboflavin']
 
my_vitamins.each do |vitamin|
  puts "#{vitamin} is tasty!"
end
=> b-12 is tasty!
=> c is tasty!
=> riboflavin is tasty!</code>

•The variable “vitamin” inside the “goalposts” refers to each item in the array as it goes through the loop. 
You can give this any name you want, but make it memorable.
•The “do” and “end” identify a block of code that will be executed for each item. 
Blocks are used extensively in Ruby.
•The “#{vitamin}” inside the double-quotes is how you insert a variable inside a string. 
There are other ways to do it, but “#{}” is the simplest.

<code>my_vitamins.each_with_index do |vitamin, index|
  puts "#{index} cheers for #{vitamin}!"
end
=> 0 cheers for b-12!
=> 1 cheers for c!
=> 2 cheers for riboflavin!</code>


<code>nouns = ['truffle', 'kiss', 'rabbit']
array_of_chocolates = nouns.map do |noun|
  "chocolate #{noun}"
end
# array_of_chocolates now has these values
=> ['chocolate truffle', 'chocolate kiss', 'chocolate rabbit']</code>


#On my blog I’m writing a Rails plugin to take data from my Mint stats installation and show a list of popular pages. 
I use “map” to put the numbers together.

<code># Get an array of rows from a database query
stats = Mint.popular_pages
 
# Assemble a summary for each
stats_report = stats.map do |stat|
  "#{stat.resource_title} was visited #{stat.visit_count} times"
end
# stats_report is now an array with these values:
=> ['Home was visited 1200 times', 'Search was visited 900 times', ...]</code>

<code># Get an array of rows from a database query
stats = Mint.popular_pages
 
# Add statistics to get total number of visits
total_visits = stats.inject(0) do |sum, stat|
total_visits = stats.inject(0) {|sum, stat| sum + stat.visit_count}
  sum  = stat.visit_count
end
=> 8800</code>
Several things are happening here:
•We start with an array of database row objects, as seen earlier.
•Inject takes an argument, which in this case is a number. This is the starting value that will be manipulated 
during each iteration of the block and returned at the end. We could have started with a blank array (“[]”), 
a blank hash (“{}”), or even an existing object.
•The arguments to the block are the variable we just initialized, and a single element from the array.

To begin with, “sum” will be zero because we sent “0” as the initializing value to inject.

“stat” will be the first item from the “stats” array. We add that page’s number of visits to the current “sum”.

That cycle repeats for all the elements in the array, gradually increasing the overall “sum”.

At the end, the final value of “sum” is returned (8,800 in this case).

So that’s a lot of functionality in a very small amount of code. In fact, you could fit it all on a single line with the optional curly-bracket syntax:


<code>total_visits = stats.inject(0) {|sum, stat| sum  = stat.visit_count}</code> =. error?
total_visits = stats.inject(0) {|sum, stat| sum + stat.visit_count} = redo
 




